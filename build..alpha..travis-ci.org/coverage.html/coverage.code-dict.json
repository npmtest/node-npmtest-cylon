{"/home/travis/build/npmtest/node-npmtest-cylon/test.js":"/* istanbul instrument in package npmtest_cylon */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-cylon/lib.npmtest_cylon.js":"/* istanbul instrument in package npmtest_cylon */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_cylon = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_cylon = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-cylon/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-cylon && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_cylon */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_cylon\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_cylon.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_cylon.rollup.js'] =\n            local.assetsDict['/assets.npmtest_cylon.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_cylon.__dirname + '/lib.npmtest_cylon.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-cylon/node_modules/cylon/index.js":"\"use strict\";\n\nvar MCP = require(\"./lib/mcp\");\n\nmodule.exports = {\n  MCP: require(\"./lib/mcp\"),\n\n  Robot: require(\"./lib/robot\"),\n\n  Driver: require(\"./lib/driver\"),\n  Adaptor: require(\"./lib/adaptor\"),\n\n  Utils: require(\"./lib/utils\"),\n  Logger: require(\"./lib/logger\"),\n\n  IO: {\n    DigitalPin: require(\"./lib/io/digital-pin\"),\n    Utils: require(\"./lib/io/utils\")\n  },\n\n  robot: MCP.create,\n  api: require(\"./lib/api\").create,\n  config: require(\"./lib/config\").update,\n\n  start: MCP.start,\n  halt: MCP.halt\n};\n\nprocess.on(\"SIGINT\", function() {\n  MCP.halt(process.kill.bind(process, process.pid));\n});\n\nif (process.platform === \"win32\") {\n  var io = { input: process.stdin, output: process.stdout },\n      quit = process.emit.bind(process, \"SIGINT\");\n\n  require(\"readline\").createInterface(io).on(\"SIGINT\", quit);\n}\n","/home/travis/build/npmtest/node-npmtest-cylon/node_modules/cylon/lib/mcp.js":"\"use strict\";\n\nvar EventEmitter = require(\"events\").EventEmitter;\n\nvar Config = require(\"./config\"),\n    Logger = require(\"./logger\"),\n    Utils = require(\"./utils\"),\n    Robot = require(\"./robot\"),\n    _ = require(\"./utils/helpers\");\n\nvar mcp = module.exports = new EventEmitter();\n\nmcp.robots = {};\nmcp.commands = {};\nmcp.events = [ \"robot_added\", \"robot_removed\" ];\n\n/**\n * Creates a new Robot with the provided options.\n *\n * @param {Object} opts robot options\n * @return {Robot} the new robot\n */\nmcp.create = function create(opts) {\n  opts = opts || {};\n\n  // check if a robot with the same name exists already\n  if (opts.name && mcp.robots[opts.name]) {\n    var original = opts.name;\n    opts.name = Utils.makeUnique(original, Object.keys(mcp.robots));\n\n    var str = \"Robot names must be unique. Renaming '\";\n    str += original + \"' to '\" + opts.name + \"'\";\n\n    Logger.log(str);\n  }\n\n  var bot = new Robot(opts);\n  mcp.robots[bot.name] = bot;\n  mcp.emit(\"robot_added\", bot.name);\n\n  return bot;\n};\n\nmcp.start = function start(callback) {\n  var fns = _.pluck(mcp.robots, \"start\");\n\n  _.parallel(fns, function() {\n    var mode = Utils.fetch(Config, \"workMode\", \"async\");\n    if (mode === \"sync\") { _.invoke(mcp.robots, \"startWork\"); }\n    callback();\n  });\n};\n\n/**\n * Halts all MCP robots.\n *\n * @param {Function} callback function to call when done halting robots\n * @return {void}\n */\nmcp.halt = function halt(callback) {\n  callback = callback || function() {};\n\n  var timeout = setTimeout(callback, Config.haltTimeout || 3000);\n\n  _.parallel(_.pluck(mcp.robots, \"halt\"), function() {\n    clearTimeout(timeout);\n    callback();\n  });\n};\n\n/**\n * Serializes MCP robots, commands, and events into a JSON-serializable Object.\n *\n * @return {Object} a serializable representation of the MCP\n */\nmcp.toJSON = function() {\n  return {\n    robots: _.invoke(mcp.robots, \"toJSON\"),\n    commands: Object.keys(mcp.commands),\n    events: mcp.events\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-cylon/node_modules/cylon/lib/config.js":"\"use strict\";\n\nvar _ = require(\"./utils/helpers\");\n\nvar config = module.exports = {},\n    callbacks = [];\n\n// default data\nconfig.haltTimeout = 3000;\nconfig.testMode = false;\nconfig.logger = null;\nconfig.silent = false;\nconfig.debug = false;\n\n/**\n * Updates the Config, and triggers handler callbacks\n *\n * @param {Object} data new configuration information to set\n * @return {Object} the updated configuration\n */\nconfig.update = function update(data) {\n  var forbidden = [\"update\", \"subscribe\", \"unsubscribe\"];\n\n  Object.keys(data).forEach(function(key) {\n    if (~forbidden.indexOf(key)) { delete data[key]; }\n  });\n\n  if (!Object.keys(data).length) {\n    return config;\n  }\n\n  _.extend(config, data);\n\n  callbacks.forEach(function(callback) { callback(data); });\n\n  return config;\n};\n\n/**\n * Subscribes a function to be called whenever the config is updated\n *\n * @param {Function} callback function to be called with updated data\n * @return {void}\n */\nconfig.subscribe = function subscribe(callback) {\n  callbacks.push(callback);\n};\n\n/**\n * Unsubscribes a callback from configuration changes\n *\n * @param {Function} callback function to unsubscribe from changes\n * @return {void}\n */\nconfig.unsubscribe = function unsubscribe(callback) {\n  var idx = callbacks.indexOf(callback);\n  if (idx >= 0) { callbacks.splice(idx, 1); }\n};\n","/home/travis/build/npmtest/node-npmtest-cylon/node_modules/cylon/lib/utils/helpers.js":"\"use strict\";\n\n/* eslint no-use-before-define: 0 */\n\nvar __slice = Array.prototype.slice;\n\nvar H = module.exports = {};\n\nfunction identity(value) {\n  return value;\n}\n\nfunction extend(base, source) {\n  var isArray = Array.isArray(source);\n\n  if (base == null) {\n    base = isArray ? [] : {};\n  }\n\n  if (isArray) {\n    source.forEach(function(e, i) {\n      if (typeof base[i] === \"undefined\") {\n        base[i] = e;\n      } else if (typeof e === \"object\") {\n        base[i] = extend(base[i], e);\n      } else if (!~base.indexOf(e)) {\n        base.push(e);\n      }\n    });\n  } else {\n    var key;\n\n    for (key in source) {\n      if (typeof source[key] !== \"object\" || !source[key]) {\n        base[key] = source[key];\n      } else if (base[key]) {\n        extend(base[key], source[key]);\n      } else {\n        base[key] = source[key];\n      }\n    }\n  }\n\n  return base;\n}\n\nextend(H, {\n  identity: identity,\n  extend: extend\n});\n\nfunction kind(thing) {\n  return Object.prototype.toString.call(thing).slice(8, -1);\n}\n\nfunction isA(type) {\n  return function(thing) {\n    return kind(thing) === type;\n  };\n}\n\nextend(H, {\n  isObject: isA(\"Object\"),\n  isObjectLoose: function(thing) { return typeof thing === \"object\"; },\n  isFunction: isA(\"Function\"),\n  isArray: isA(\"Array\"),\n  isString: isA(\"String\"),\n  isNumber: isA(\"Number\"),\n  isArguments: isA(\"Arguments\"),\n  isUndefined: isA(\"Undefined\")\n});\n\nfunction iterate(thing, fn, thisVal) {\n  if (H.isArray(thing)) {\n    thing.forEach(fn, thisVal);\n    return;\n  }\n\n  if (H.isObject(thing)) {\n    for (var key in thing) {\n      var value = thing[key];\n      fn.call(thisVal, value, key);\n    }\n  }\n}\n\nfunction pluck(collection, key) {\n  var keys = [];\n\n  iterate(collection, function(object) {\n    if (H.isObject(object)) {\n      if (H.isFunction(object[key])) {\n        keys.push(object[key].bind(object));\n      } else {\n        keys.push(object[key]);\n      }\n    }\n  });\n\n  return keys;\n}\n\nfunction map(collection, fn, thisVal) {\n  var vals = [];\n\n  if (fn == null) {\n    fn = identity;\n  }\n\n  iterate(collection, function(object, index) {\n    vals.push(fn.call(thisVal, object, index));\n  });\n\n  return vals;\n}\n\nfunction invoke(collection, fn) {\n  var args = __slice.call(arguments, 2),\n      vals = [];\n\n  iterate(collection, function(object) {\n    if (H.isFunction(fn)) {\n      vals.push(fn.apply(object, args));\n      return;\n    }\n\n    vals.push(object[fn].apply(object, arguments));\n  });\n\n  return vals;\n}\n\nfunction reduce(collection, iteratee, accumulator, thisVal) {\n  var isArray = H.isArray(collection);\n\n  if (!isArray && !H.isObjectLoose(collection)) {\n    return null;\n  }\n\n  if (iteratee == null) {\n    iteratee = identity;\n  }\n\n  if (accumulator == null) {\n    if (isArray) {\n      accumulator = collection.shift();\n    } else {\n      for (var key in collection) {\n        accumulator = collection[key];\n        delete collection[key];\n        break;\n      }\n    }\n  }\n\n  iterate(collection, function(object, name) {\n    accumulator = iteratee.call(thisVal, accumulator, object, name);\n  });\n\n  return accumulator;\n}\n\nextend(H, {\n  pluck: pluck,\n  each: iterate,\n  map: map,\n  invoke: invoke,\n  reduce: reduce\n});\n\nfunction arity(fn, n) {\n  return function() {\n    var args = __slice.call(arguments, 0, n);\n    return fn.apply(null, args);\n  };\n}\n\nfunction partial(fn) {\n  var args = __slice.call(arguments, 1);\n\n  return function() {\n    return fn.apply(null, args.concat(__slice.call(arguments)));\n  };\n}\n\nfunction partialRight(fn) {\n  var args = __slice.call(arguments, 1);\n\n  return function() {\n    return fn.apply(null, __slice.call(arguments).concat(args));\n  };\n}\n\nextend(H, {\n  arity: arity,\n  partial: partial,\n  partialRight: partialRight\n});\n\nfunction includes(arr, value) {\n  return !!~arr.indexOf(value);\n}\n\nextend(H, {\n  includes: includes\n});\n\nfunction parallel(functions, done) {\n  var total = functions.length,\n      completed = 0,\n      results = [],\n      error;\n\n  if (typeof done !== \"function\") { done = function() {}; }\n\n  function callback(err, result) {\n    if (error) {\n      return;\n    }\n\n    if (err || error) {\n      error = err;\n      done(err);\n      return;\n    }\n\n    completed++;\n    results.push(result);\n\n    if (completed === total) {\n      done(null, results);\n    }\n  }\n\n  if (!functions.length) { done(); }\n\n  functions.forEach(function(fn) { fn(callback); });\n}\n\nextend(H, {\n  parallel: parallel\n});\n\nfunction series(functions, done) {\n  var results = [],\n      error;\n\n  if (typeof done !== \"function\") { done = function() {}; }\n\n  function callback(err, result) {\n    if (err || error) {\n      error = err;\n      return done(err);\n    }\n\n    results.push(result);\n\n    if (!functions.length) {\n      return done(null, results);\n    }\n\n    next();\n  }\n\n  function next() {\n    functions.shift()(callback);\n  }\n\n  if (!functions.length) { done(null, results); }\n  next();\n}\n\nextend(H, {\n  series: series\n});\n","/home/travis/build/npmtest/node-npmtest-cylon/node_modules/cylon/lib/logger.js":"\"use strict\";\n\n/* eslint no-use-before-define: 0 */\n\nvar Config = require(\"./config\"),\n    _ = require(\"./utils/helpers\");\n\nvar BasicLogger = function basiclogger(str) {\n  var prefix = new Date().toISOString() + \" : \";\n  console.log(prefix + str);\n};\n\nvar NullLogger = function nulllogger() {};\n\nvar Logger = module.exports = {\n  setup: setup,\n\n  should: {\n    log: true,\n    debug: false\n  },\n\n  log: function log(str) {\n    if (Logger.should.log) {\n      Logger.logger.call(Logger.logger, str);\n    }\n  },\n\n  debug: function debug(str) {\n    if (Logger.should.log && Logger.should.debug) {\n      Logger.logger.call(Logger.logger, str);\n    }\n  }\n};\n\nfunction setup(opts) {\n  if (_.isObject(opts)) { _.extend(Config, opts); }\n\n  var logger = Config.logger;\n\n  // if no logger supplied, use basic logger\n  if (logger == null) { logger = BasicLogger; }\n\n  // if logger is still falsy, use NullLogger\n  Logger.logger = logger || NullLogger;\n\n  Logger.should.log = !Config.silent;\n  Logger.should.debug = Config.debug;\n\n  // --silent CLI flag overrides\n  if (_.includes(process.argv, \"--silent\")) {\n    Logger.should.log = false;\n  }\n\n  // --debug CLI flag overrides\n  if (_.includes(process.argv, \"--debug\")) {\n    Logger.should.debug = false;\n  }\n\n  return Logger;\n}\n\nsetup();\nConfig.subscribe(setup);\n\n// deprecated holdovers\n[\"info\", \"warn\", \"error\", \"fatal\"].forEach(function(method) {\n  var called = false;\n\n  function showDeprecationNotice() {\n    console.log(\"The method Logger#\" + method + \" has been deprecated.\");\n    console.log(\"It will be removed in Cylon 2.0.0.\");\n    console.log(\"Please switch to using the #log or #debug Logger methods\");\n\n    called = true;\n  }\n\n  Logger[method] = function() {\n    if (!called) { showDeprecationNotice(); }\n    Logger.log.apply(null, arguments);\n  };\n});\n","/home/travis/build/npmtest/node-npmtest-cylon/node_modules/cylon/lib/utils.js":"\"use strict\";\n\nvar _ = require(\"./utils/helpers\");\n\nvar monkeyPatches = require(\"./utils/monkey-patches\");\n\nvar Utils = module.exports = {\n  /**\n   * A wrapper around setInterval to provide a more english-like syntax\n   * (e.g. \"every 5 seconds, do this thing\")\n   *\n   * @param {Number} interval delay between action invocations\n   * @param {Function} action function to trigger every time interval elapses\n   * @example every((5).seconds(), function() {});\n   * @return {intervalID} setInterval ID to pass to clearInterval()\n   */\n  every: function every(interval, action) {\n    return setInterval(action, interval);\n  },\n\n  /**\n   * A wrapper around setInterval to provide a more english-like syntax\n   * (e.g. \"after 5 seconds, do this thing\")\n   *\n   * @param {Number} delay how long to wait\n   * @param {Function} action action to perform after delay\n   * @example after((5).seconds(), function() {});\n   * @return {timeoutId} setTimeout ID to pass to clearTimeout()\n   */\n  after: function after(delay, action) {\n    return setTimeout(action, delay);\n  },\n\n  /**\n   * A wrapper around setInterval, with a delay of 0ms\n   *\n   * @param {Function} action function to invoke constantly\n   * @example constantly(function() {});\n   * @return {intervalID} setInterval ID to pass to clearInterval()\n   */\n  constantly: function constantly(action) {\n    return every(0, action);\n  },\n\n  /**\n   * A wrapper around clearInterval\n   *\n   * @param {intervalID} intervalID ID of every/after/constantly\n   * @example finish(blinking);\n   * @return {void}\n   */\n  finish: function finish(intervalID) {\n    clearInterval(intervalID);\n  },\n\n  /**\n   * Sleeps the program for a period of time.\n   *\n   * Use of this is not advised, as your program can't do anything else while\n   * it's running.\n   *\n   * @param {Number} ms number of milliseconds to sleep\n   * @return {void}\n   */\n  sleep: function sleep(ms) {\n    var start = Date.now(),\n        i = 0;\n\n    while (Date.now() < start + ms) {\n      i = i.toString();\n    }\n  },\n\n  /**\n   * Utility for providing class inheritance.\n   *\n   * Based on CoffeeScript's implementation of inheritance.\n   *\n   * Parent class methods/properites are available on Child.__super__.\n   *\n   * @param {Function} child the descendent class\n   * @param {Function} parent the parent class\n   * @return {Function} the child class\n   */\n  subclass: function subclass(child, parent) {\n    var Ctor = function() {\n      this.constructor = child;\n    };\n\n    for (var key in parent) {\n      if (parent.hasOwnProperty(key)) {\n        child[key] = parent[key];\n      }\n    }\n\n    Ctor.prototype = parent.prototype;\n    child.prototype = new Ctor();\n    child.__super__ = parent.prototype;\n    return child;\n  },\n\n  proxyFunctions: function proxyFunctions(source, target) {\n    _.each(source, function(prop, key) {\n      if (_.isFunction(prop) && !target[key]) {\n        target[key] = prop.bind(source);\n      }\n    });\n  },\n\n  /**\n   * Proxies calls from all methods in the source to a target object\n   *\n   * @param {String[]} methods methods to proxy\n   * @param {Object} target object to proxy methods to\n   * @param {Object} [base=this] object to proxy methods from\n   * @param {Boolean} [force=false] whether to overwrite existing methods\n   * @return {Object} the base\n   */\n  proxyFunctionsToObject: function(methods, target, base, force) {\n    if (base == null) {\n      base = this;\n    }\n\n    force = force || false;\n\n    methods.forEach(function(method) {\n      if (_.isFunction(base[method]) && !force) {\n        return;\n      }\n\n      base[method] = function() {\n        return target[method].apply(target, arguments);\n      };\n    });\n\n    return base;\n  },\n\n  classCallCheck: function(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  },\n\n  /**\n   * Approximation of Ruby's Hash#fetch method for object property lookup\n   *\n   * @param {Object} obj object to do lookup on\n   * @param {String} property property name to attempt to access\n   * @param {*} fallback a fallback value if property can't be found. if\n   * a function, will be invoked with the string property name.\n   * @throws Error if fallback needed but not provided, or fallback fn doesn't\n   * return anything\n   * @example\n   *    fetch({ property: \"hello world\" }, \"property\"); //=> \"hello world\"\n   * @example\n   *    fetch({}, \"notaproperty\", \"default value\"); //=> \"default value\"\n   * @example\n   *    var notFound = function(prop) { return prop + \" not found!\" };\n   *    fetch({}, \"notaproperty\", notFound); //=> \"notaproperty not found!\"\n   * @example\n   *    var badFallback = function(prop) { prop + \" not found!\" };\n   *    fetch({}, \"notaproperty\", badFallback);\n   *    // Error: no return value from provided callback function\n   * @example\n   *    fetch(object, \"notaproperty\");\n   *    // Error: key not found: \"notaproperty\"\n   * @return {*} fetched property, fallback, or fallback function return value\n   */\n  fetch: function(obj, property, fallback) {\n    if (obj.hasOwnProperty(property)) {\n      return obj[property];\n    }\n\n    if (fallback === void 0) {\n      throw new Error(\"key not found: \\\"\" + property + \"\\\"\");\n    }\n\n    if (_.isFunction(fallback)) {\n      var value = fallback(property);\n\n      if (value === void 0) {\n        throw new Error(\"no return value from provided fallback function\");\n      }\n\n      return value;\n    }\n\n    return fallback;\n  },\n\n  /**\n   * Given a name, and an array of existing names, returns a unique new name\n   *\n   * @param {String} name the name that's colliding with existing names\n   * @param {String[]} arr array of existing names\n   * @example\n   *   makeUnique(\"hello\", [\"hello\", \"hello-1\", \"hello-2\"]); //=> \"hello3\"\n   * @return {String} the new name\n   */\n  makeUnique: function(name, arr) {\n    var newName;\n\n    if (!~arr.indexOf(name)) {\n      return name;\n    }\n\n    for (var n = 1; ; n++) {\n      newName = name + \"-\" + n;\n      if (!~arr.indexOf(newName)) {\n        return newName;\n      }\n    }\n  },\n\n  /**\n   * Adds every/after/constantly to the global namespace, and installs\n   * monkey-patches.\n   *\n   * @return {Object} utils object\n   */\n  bootstrap: function bootstrap() {\n    global.every = this.every;\n    global.after = this.after;\n    global.constantly = this.constantly;\n\n    monkeyPatches.install();\n\n    return this;\n  }\n};\n\nUtils.bootstrap();\n","/home/travis/build/npmtest/node-npmtest-cylon/node_modules/cylon/lib/utils/monkey-patches.js":"/* eslint no-extend-native: 0 key-spacing: 0 */\n\n\"use strict\";\n\nvar max = Math.max,\n    min = Math.min;\n\nvar originals = {\n  seconds:   Number.prototype.seconds,\n  second:    Number.prototype.second,\n  fromScale: Number.prototype.fromScale,\n  toScale:   Number.prototype.toScale\n};\n\nmodule.exports.uninstall = function() {\n  for (var opt in originals) {\n    if (originals[opt] == null) {\n      Number.prototype[opt] = originals[opt];\n    } else {\n      delete Number.prototype[opt];\n    }\n  }\n};\n\nmodule.exports.install = function() {\n  /**\n   * Multiplies a number by 60000 to convert minutes\n   * to milliseconds\n   *\n   * @example\n   * (2).minutes(); //=> 120000\n   * @return {Number} time in milliseconds\n   */\n  Number.prototype.minutes = function() {\n    return this * 60000;\n  };\n\n  /**\n   * Alias for Number.prototype.minutes\n   *\n   * @see Number.prototype.minute\n   * @example\n   * (1).minute(); //=>60000\n   * @return {Number} time in milliseconds\n   */\n  Number.prototype.minute = Number.prototype.minutes;\n\n  /**\n   * Multiplies a number by 1000 to convert seconds\n   * to milliseconds\n   *\n   * @example\n   * (2).seconds(); //=> 2000\n   * @return {Number} time in milliseconds\n   */\n  Number.prototype.seconds = function() {\n    return this * 1000;\n  };\n\n  /**\n   * Alias for Number.prototype.seconds\n   *\n   * @see Number.prototype.seconds\n   * @example\n   * (1).second(); //=> 1000\n   * @return {Number} time in milliseconds\n   */\n  Number.prototype.second = Number.prototype.seconds;\n\n  /**\n   * Passthru to get time in milliseconds\n   *\n   * @example\n   * (200).milliseconds(); //=> 200\n   * @return {Number} time in milliseconds\n   */\n  Number.prototype.milliseconds = function() {\n    return this;\n  };\n\n  /**\n   * Alias for Number.prototype.milliseconds\n   *\n   * @see Number.prototype.milliseconds\n   * @example\n   * (100).ms(); //=> 100\n   * @return {Number} time in milliseconds\n   */\n  Number.prototype.ms = Number.prototype.milliseconds;\n\n  /**\n   * Converts microseconds to milliseconds.\n   * Note that timing of events in terms of microseconds\n   * is not very accurate in JS.\n   *\n   * @example\n   * (2000).microseconds(); //=> 2\n   * @return {Number} time in milliseconds\n   */\n  Number.prototype.microseconds = function() {\n    return this / 1000;\n  };\n\n  /**\n   * Converts a number from a current scale to a 0 - 1 scale.\n   *\n   * @param {Number} start low point of scale to convert from\n   * @param {Number} end high point of scale to convert from\n   * @example\n   * (5).fromScale(0, 10) //=> 0.5\n   * @return {Number} the scaled value\n   */\n  Number.prototype.fromScale = function(start, end) {\n    var val = (this - min(start, end)) / (max(start, end) - min(start, end));\n\n    if (val > 1) {\n      return 1;\n    }\n\n    if (val < 0) {\n      return 0;\n    }\n\n    return val;\n  };\n\n  /**\n   * Converts a number from a 0 - 1 scale to the specified scale.\n   *\n   * @param {Number} start low point of scale to convert to\n   * @param {Number} end high point of scale to convert to\n   * @example\n   * (0.5).toScale(0, 10) //=> 5\n   * @return {Number} the scaled value\n   */\n  Number.prototype.toScale = function(start, end) {\n    var i = this * (max(start, end) - min(start, end)) + min(start, end);\n\n    if (i < start) {\n      return start;\n    }\n\n    if (i > end) {\n      return end;\n    }\n\n    return i;\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-cylon/node_modules/cylon/lib/robot.js":"\"use strict\";\n\nvar initializer = require(\"./initializer\"),\n    Logger = require(\"./logger\"),\n    Utils = require(\"./utils\"),\n    Config = require(\"./config\"),\n    _ = require(\"./utils/helpers\");\n\nvar validator = require(\"./validator\");\n\nvar EventEmitter = require(\"events\").EventEmitter;\n\n// used when creating default robot names\nvar ROBOT_ID = 1;\n\n/**\n * Creates a new Robot instance based on provided options\n *\n * @constructor\n * @param {Object} opts object with Robot options\n * @param {String} [name] the name the robot should have\n * @param {Object} [connections] object containing connection info for the Robot\n * @param {Object} [devices] object containing device information for the Robot\n * @param {Function} [work] a function the Robot will run when started\n * @returns {Robot} new Robot instance\n */\nvar Robot = module.exports = function Robot(opts) {\n  Utils.classCallCheck(this, Robot);\n\n  opts = opts || {};\n\n  validator.validate(opts);\n\n  // auto-bind prototype methods\n  for (var prop in Object.getPrototypeOf(this)) {\n    if (this[prop] && prop !== \"constructor\") {\n      this[prop] = this[prop].bind(this);\n    }\n  }\n\n  this.initRobot(opts);\n\n  _.each(opts, function(opt, name) {\n    if (this[name] !== undefined) {\n      return;\n    }\n\n    if (_.isFunction(opt)) {\n      this[name] = opt.bind(this);\n\n      if (opts.commands == null) {\n        this.commands[name] = opt.bind(this);\n      }\n    } else {\n      this[name] = opt;\n    }\n  }, this);\n\n  if (opts.commands) {\n    var cmds;\n\n    if (_.isFunction(opts.commands)) {\n      cmds = opts.commands.call(this);\n    } else {\n      cmds = opts.commands;\n    }\n\n    if (_.isObject(cmds)) {\n      this.commands = cmds;\n    } else {\n      var err = \"#commands must be an object \";\n      err += \"or a function that returns an object\";\n      throw new Error(err);\n    }\n  }\n\n  var mode = Utils.fetch(Config, \"mode\", \"manual\");\n\n  if (mode === \"auto\") {\n    // run on the next tick, to allow for \"work\" event handlers to be set up\n    setTimeout(this.start, 0);\n  }\n};\n\nUtils.subclass(Robot, EventEmitter);\n\n/**\n * Condenses information on a Robot to a JSON-serializable format\n *\n * @return {Object} serializable information on the Robot\n */\nRobot.prototype.toJSON = function() {\n  return {\n    name: this.name,\n    connections: _.invoke(this.connections, \"toJSON\"),\n    devices: _.invoke(this.devices, \"toJSON\"),\n    commands: Object.keys(this.commands),\n    events: _.isArray(this.events) ? this.events : []\n  };\n};\n\n/**\n * Adds a new Connection to the Robot with the provided name and details.\n *\n * @param {String} name string name for the Connection to use\n * @param {Object} conn options for the Connection initializer\n * @return {Object} the robot\n */\nRobot.prototype.connection = function(name, conn) {\n  conn.robot = this;\n  conn.name = name;\n\n  if (this.connections[conn.name]) {\n    var original = conn.name,\n        str;\n\n    conn.name = Utils.makeUnique(original, Object.keys(this.connections));\n\n    str = \"Connection names must be unique.\";\n    str += \"Renaming '\" + original + \"' to '\" + conn.name + \"'\";\n    this.log(str);\n  }\n  if (\"adapter\" in conn) {\n    conn.adaptor = conn.adapter;\n  }\n  this.connections[conn.name] = initializer(\"adaptor\", conn);\n\n  return this;\n};\n\n/**\n * Initializes all values for a new Robot.\n *\n * @param {Object} opts object passed to Robot constructor\n * @return {void}\n */\nRobot.prototype.initRobot = function(opts) {\n  this.name = opts.name || \"Robot \" + ROBOT_ID++;\n  this.running = false;\n\n  this.connections = {};\n  this.devices = {};\n\n  this.work = opts.work || opts.play;\n\n  this.commands = {};\n\n  if (!this.work) {\n    this.work = function() { this.log(\"No work yet.\"); };\n  }\n\n  _.each(opts.connections, function(conn, key) {\n    var name = _.isString(key) ? key : conn.name;\n\n    if (conn.devices) {\n      opts.devices = opts.devices || {};\n\n      _.each(conn.devices, function(device, d) {\n        device.connection = name;\n        opts.devices[d] = device;\n      });\n\n      delete conn.devices;\n    }\n\n    this.connection(name, _.extend({}, conn));\n  }, this);\n\n  _.each(opts.devices, function(device, key) {\n    var name = _.isString(key) ? key : device.name;\n    this.device(name, _.extend({}, device));\n  }, this);\n};\n\n/**\n * Adds a new Device to the Robot with the provided name and details.\n *\n * @param {String} name string name for the Device to use\n * @param {Object} device options for the Device initializer\n * @return {Object} the robot\n */\nRobot.prototype.device = function(name, device) {\n  var str;\n\n  device.robot = this;\n  device.name = name;\n\n  if (this.devices[device.name]) {\n    var original = device.name;\n    device.name = Utils.makeUnique(original, Object.keys(this.devices));\n\n    str = \"Device names must be unique.\";\n    str += \"Renaming '\" + original + \"' to '\" + device.name + \"'\";\n    this.log(str);\n  }\n\n  if (_.isString(device.connection)) {\n    if (this.connections[device.connection] == null) {\n      str = \"No connection found with the name \" + device.connection + \".\\n\";\n      this.log(str);\n      process.emit(\"SIGINT\");\n    }\n\n    device.connection = this.connections[device.connection];\n  } else {\n    for (var c in this.connections) {\n      device.connection = this.connections[c];\n      break;\n    }\n  }\n\n  this.devices[device.name] = initializer(\"driver\", device);\n\n  return this;\n};\n\n/**\n * Starts the Robot's connections, then devices, then work.\n *\n * @param {Function} callback function to be triggered when the Robot has\n * started working\n * @return {Object} the Robot\n */\nRobot.prototype.start = function(callback) {\n  if (this.running) {\n    return this;\n  }\n\n  var mode = Utils.fetch(Config, \"workMode\", \"async\");\n\n  var start = function() {\n    if (mode === \"async\") {\n      this.startWork();\n    }\n  }.bind(this);\n\n  _.series([\n    this.startConnections,\n    this.startDevices,\n    start\n  ], function(err, results) {\n    if (err) {\n      this.log(\"An error occured while trying to start the robot:\");\n      this.log(err);\n\n      this.halt(function() {\n        if (_.isFunction(this.error)) {\n          this.error.call(this, err);\n        }\n\n        if (this.listeners(\"error\").length) {\n          this.emit(\"error\", err);\n        }\n      }.bind(this));\n    }\n\n    if (_.isFunction(callback)) {\n      callback(err, results);\n    }\n  }.bind(this));\n\n  return this;\n};\n\n/**\n * Starts the Robot's work function\n *\n * @return {void}\n */\nRobot.prototype.startWork = function() {\n  this.log(\"Working.\");\n\n  this.emit(\"ready\", this);\n  this.work.call(this, this);\n  this.running = true;\n};\n\n/**\n * Starts the Robot's connections\n *\n * @param {Function} callback function to be triggered after the connections are\n * started\n * @return {void}\n */\nRobot.prototype.startConnections = function(callback) {\n  this.log(\"Starting connections.\");\n\n  var starters = _.map(this.connections, function(conn) {\n    return function(cb) {\n      return this.startConnection(conn, cb);\n    }.bind(this);\n  }, this);\n\n  return _.parallel(starters, callback);\n};\n\n/**\n * Starts a single connection on Robot\n *\n * @param {Object} connection to start\n * @param {Function} callback function to be triggered after the connection is\n * started\n * @return {void}\n */\nRobot.prototype.startConnection = function(connection, callback) {\n  if (connection.connected === true) {\n    return callback.call(connection);\n  }\n\n  var str = \"Starting connection '\" + connection.name + \"'\";\n\n  if (connection.host) {\n    str += \" on host \" + connection.host;\n  } else if (connection.port) {\n    str += \" on port \" + connection.port;\n  }\n\n  this.log(str + \".\");\n  this[connection.name] = connection;\n  connection.connect.call(connection, callback);\n  connection.connected = true;\n  return true;\n};\n\n/**\n * Starts the Robot's devices\n *\n * @param {Function} callback function to be triggered after the devices are\n * started\n * @return {void}\n */\nRobot.prototype.startDevices = function(callback) {\n  var log = this.log;\n\n  log(\"Starting devices.\");\n\n  var starters = _.map(this.devices, function(device) {\n    return function(cb) {\n      return this.startDevice(device, cb);\n    }.bind(this);\n  }, this);\n\n  return _.parallel(starters, callback);\n};\n\n/**\n * Starts a single device on Robot\n *\n * @param {Object} device to start\n * @param {Function} callback function to be triggered after the device is\n * started\n * @return {void}\n */\nRobot.prototype.startDevice = function(device, callback) {\n  if (device.started === true) {\n    return callback.call(device);\n  }\n\n  var log = this.log;\n  var str = \"Starting device '\" + device.name + \"'\";\n\n  if (device.pin) {\n    str += \" on pin \" + device.pin;\n  }\n\n  log(str + \".\");\n  this[device.name] = device;\n  device.start.call(device, callback);\n  device.started = true;\n\n  return device.started;\n};\n\n/**\n * Halts the Robot, attempting to gracefully stop devices and connections.\n *\n * @param {Function} callback to be triggered when the Robot has stopped\n * @return {void}\n */\nRobot.prototype.halt = function(callback) {\n  callback = callback || function() {};\n\n  if (!this.running) {\n    return callback();\n  }\n\n  // ensures callback(err) won't prevent others from halting\n  function wrap(fn) {\n    return function(cb) { fn.call(null, cb.bind(null, null)); };\n  }\n\n  var devices = _.pluck(this.devices, \"halt\").map(wrap),\n      connections = _.pluck(this.connections, \"disconnect\").map(wrap);\n\n  try {\n    _.parallel(devices, function() {\n      _.parallel(connections, callback);\n    });\n  } catch (e) {\n    var msg = \"An error occured while attempting to safely halt the robot\";\n    this.log(msg);\n    this.log(e.message);\n  }\n\n  this.running = false;\n};\n\n/**\n * Generates a String representation of a Robot\n *\n * @return {String} representation of a Robot\n */\nRobot.prototype.toString = function() {\n  return \"[Robot name='\" + this.name + \"']\";\n};\n\nRobot.prototype.log = function(str) {\n  Logger.log(\"[\" + this.name + \"] - \" + str);\n};\n","/home/travis/build/npmtest/node-npmtest-cylon/node_modules/cylon/lib/initializer.js":"\"use strict\";\n\nvar Registry = require(\"./registry\"),\n    Config = require(\"./config\"),\n    _ = require(\"./utils/helpers\");\n\nfunction testMode() {\n  return process.env.NODE_ENV === \"test\" && Config.testMode;\n}\n\nmodule.exports = function Initializer(type, opts) {\n  var mod;\n\n  mod = Registry.findBy(type, opts[type]);\n\n  if (!mod) {\n    if (opts.module) {\n      Registry.register(opts.module);\n    } else {\n      Registry.register(\"cylon-\" + opts[type]);\n    }\n\n    mod = Registry.findBy(type, opts[type]);\n  }\n\n  if (!mod) {\n    var err = [ \"Unable to find\", type, \"for\", opts[type] ].join(\" \");\n    throw new Error(err);\n  }\n\n  var obj = mod[type](opts);\n\n  _.each(obj, function(prop, name) {\n    if (name === \"constructor\") {\n      return;\n    }\n\n    if (_.isFunction(prop)) {\n      obj[name] = prop.bind(obj);\n    }\n  });\n\n  if (testMode()) {\n    var test = Registry.findBy(type, \"test\")[type](opts);\n\n    _.each(obj, function(prop, name) {\n      if (_.isFunction(prop) && !test[name]) {\n        test[name] = function() { return true; };\n      }\n    });\n\n    return test;\n  }\n\n  return obj;\n};\n","/home/travis/build/npmtest/node-npmtest-cylon/node_modules/cylon/lib/registry.js":"\"use strict\";\n\nvar Logger = require(\"./logger\"),\n    _ = require(\"./utils/helpers\"),\n    path = require(\"path\");\n\n// Explicitly these modules here, so Browserify can grab them later\nrequire(\"./test/loopback\");\nrequire(\"./test/test-adaptor\");\nrequire(\"./test/test-driver\");\nrequire(\"./test/ping\");\n\nvar missingModuleError = function(module) {\n  var str = \"Cannot find the '\" + module + \"' module.\\n\";\n  str += \"This problem might be fixed by installing it with \";\n  str += \"'npm install \" + module + \"' and trying again.\";\n\n  console.log(str);\n\n  process.emit(\"SIGINT\");\n};\n\nvar Registry = module.exports = {\n  data: {},\n\n  register: function(module) {\n    if (this.data[module]) {\n      return this.data[module].module;\n    }\n\n    var pkg;\n\n    try {\n      if (this.isModuleInDevelopment(module)) {\n        pkg = require(path.resolve(\".\") + \"/index\");\n      } else {\n        pkg = require(module);\n      }\n    } catch (e) {\n      if (e.code === \"MODULE_NOT_FOUND\") {\n        missingModuleError(module);\n      }\n\n      throw e;\n    }\n\n    this.data[module] = {\n      module: pkg,\n      adaptors: pkg.adaptors || [],\n      drivers: pkg.drivers || [],\n      dependencies: pkg.dependencies || []\n    };\n\n    this.logRegistration(module, this.data[module]);\n\n    this.data[module].dependencies.forEach(function(dep) {\n      Registry.register(dep);\n    });\n\n    return this.data[module].module;\n  },\n\n  findBy: function(prop, name) {\n    // pluralize, if necessary\n    if (prop.slice(-1) !== \"s\") {\n      prop += \"s\";\n    }\n\n    return this.search(prop, name);\n  },\n\n  findByModule: function(module) {\n    if (!this.data[module]) {\n      return null;\n    }\n\n    return this.data[module].module;\n  },\n\n  logRegistration: function(name) {\n    var module = this.data[name];\n\n    Logger.debug(\"Registering module \" + name);\n\n    [\"adaptors\", \"drivers\", \"dependencies\"].forEach(function(field) {\n      if (module[field].length) {\n        Logger.debug(\"  \" + field + \":\");\n        module[field].forEach(function(item) {\n          Logger.debug(\"    - \" + item);\n        });\n      }\n    });\n  },\n\n  search: function(entry, value) {\n    for (var name in this.data) {\n      if (this.data.hasOwnProperty(name)) {\n        var repo = this.data[name];\n\n        if (repo[entry] && _.includes(repo[entry], value)) {\n          return repo.module;\n        }\n      }\n    }\n\n    return false;\n  },\n\n  isModuleInDevelopment: function(module) {\n    return (path.basename(path.resolve(\".\")) === module);\n  }\n};\n\n// Default drivers/adaptors:\n[\"loopback\", \"ping\", \"test-adaptor\", \"test-driver\"].forEach(function(module) {\n  Registry.register(\"./test/\" + module);\n});\n","/home/travis/build/npmtest/node-npmtest-cylon/node_modules/cylon/lib/test/loopback.js":"\"use strict\";\n\nvar Adaptor = require(\"../adaptor\"),\n    Utils = require(\"../utils\");\n\nvar Loopback = module.exports = function Loopback() {\n  Loopback.__super__.constructor.apply(this, arguments);\n};\n\nUtils.subclass(Loopback, Adaptor);\n\nLoopback.prototype.connect = function(callback) {\n  callback();\n};\n\nLoopback.prototype.disconnect = function(callback) {\n  callback();\n};\n\nLoopback.adaptors = [\"loopback\"];\nLoopback.adaptor = function(opts) { return new Loopback(opts); };\n","/home/travis/build/npmtest/node-npmtest-cylon/node_modules/cylon/lib/adaptor.js":"\"use strict\";\n\nvar Basestar = require(\"./basestar\"),\n    Utils = require(\"./utils\"),\n    _ = require(\"./utils/helpers\");\n\nfunction formatErrorMessage(name, message) {\n  return [\"Error in connection\", \"'\" + name + \"'\", \"- \" + message].join(\" \");\n}\n\n/**\n * Adaptor class\n *\n * @constructor Adaptor\n *\n * @param {Object} [opts] adaptor options\n * @param {String} [opts.name] the adaptor's name\n * @param {Object} [opts.robot] the robot the adaptor belongs to\n * @param {Object} [opts.host] the host the adaptor will connect to\n * @param {Object} [opts.port] the port the adaptor will connect to\n */\nvar Adaptor = module.exports = function Adaptor(opts) {\n  Adaptor.__super__.constructor.apply(this, arguments);\n\n  opts = opts || {};\n\n  this.name = opts.name;\n\n  // the Robot the adaptor belongs to\n  this.robot = opts.robot;\n\n  // some default options\n  this.host = opts.host;\n  this.port = opts.port;\n\n  // misc. details provided in args hash\n  this.details = {};\n\n  _.each(opts, function(opt, name) {\n    if (!_.includes([\"robot\", \"name\", \"adaptor\", \"events\"], name)) {\n      this.details[name] = opt;\n    }\n  }, this);\n};\n\nUtils.subclass(Adaptor, Basestar);\n\n/**\n * A base connect function. Must be overwritten by a descendent.\n *\n * @throws Error if not overridden by a child class\n * @return {void}\n */\nAdaptor.prototype.connect = function() {\n  var message = formatErrorMessage(\n    this.name,\n    \"Adaptor#connect method must be overwritten by descendant classes.\"\n  );\n\n  throw new Error(message);\n};\n\n/**\n * A base disconnect function. Must be overwritten by a descendent.\n *\n * @throws Error if not overridden by a child class\n * @return {void}\n */\nAdaptor.prototype.disconnect = function() {\n  var message = formatErrorMessage(\n    this.name,\n    \"Adaptor#disconnect method must be overwritten by descendant classes.\"\n  );\n\n  throw new Error(message);\n};\n\n/**\n * Expresses the Adaptor in a JSON-serializable format\n *\n * @return {Object} a representation of the Adaptor in a serializable format\n */\nAdaptor.prototype.toJSON = function() {\n  return {\n    name: this.name,\n    adaptor: this.constructor.name || this.name,\n    details: this.details\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-cylon/node_modules/cylon/lib/basestar.js":"\"use strict\";\n\nvar EventEmitter = require(\"events\").EventEmitter;\n\nvar Utils = require(\"./utils\"),\n    _ = require(\"./utils/helpers\");\n\n/**\n * The Basestar class is a wrapper class around EventEmitter that underpins most\n * other Cylon adaptor/driver classes, providing useful external base methods\n * and functionality.\n *\n * @constructor Basestar\n */\nvar Basestar = module.exports = function Basestar() {\n  Utils.classCallCheck(this, Basestar);\n};\n\nUtils.subclass(Basestar, EventEmitter);\n\n/**\n * Proxies calls from all methods in the source to a target object\n *\n * @param {String[]} methods methods to proxy\n * @param {Object} target object to proxy methods to\n * @param {Object} source object to proxy methods from\n * @param {Boolean} [force=false] whether or not to overwrite existing methods\n * @return {Object} the source\n */\nBasestar.prototype.proxyMethods = Utils.proxyFunctionsToObject;\n\n/**\n * Triggers the provided callback, and emits an event with the provided data.\n *\n * If an error is provided, emits the 'error' event.\n *\n * @param {String} event what event to emit\n * @param {Function} callback function to be invoked with error/data\n * @param {*} err possible error value\n * @param {...*} data data values to be passed to error/callback\n * @return {void}\n */\nBasestar.prototype.respond = function(event, callback, err) {\n  var args = Array.prototype.slice.call(arguments, 3);\n\n  if (err) {\n    this.emit(\"error\", err);\n  } else {\n    this.emit.apply(this, [event].concat(args));\n  }\n\n  if (typeof callback === \"function\") {\n    callback.apply(this, [err].concat(args));\n  }\n};\n\n/**\n * Defines an event handler to proxy events from a source object to a target\n *\n * @param {Object} opts event options\n * @param {EventEmitter} opts.source source of events to listen for\n * @param {EventEmitter} opts.target target new events should be emitted from\n * @param {String} opts.eventName name of event to listen for, and proxy\n * @param {Bool} [opts.sendUpdate=false] whether to emit the 'update' event\n * @param {String} [opts.targetEventName] new event name to emit from target\n * @return {EventEmitter} the source object\n */\nBasestar.prototype.defineEvent = function(opts) {\n  opts.sendUpdate = opts.sendUpdate || false;\n  opts.targetEventName = opts.targetEventName || opts.eventName;\n\n  opts.source.on(opts.eventName, function() {\n    var args = arguments.length >= 1 ? [].slice.call(arguments, 0) : [];\n    args.unshift(opts.targetEventName);\n    opts.target.emit.apply(opts.target, args);\n\n    if (opts.sendUpdate) {\n      args.unshift(\"update\");\n      opts.target.emit.apply(opts.target, args);\n    }\n  });\n\n  return opts.source;\n};\n\n/**\n * A #defineEvent shorthand for adaptors.\n *\n * Proxies events from an adaptor's connector to the adaptor itself.\n *\n * @param {Object} opts proxy options\n * @return {EventEmitter} the adaptor's connector\n */\nBasestar.prototype.defineAdaptorEvent = function(opts) {\n  return this._proxyEvents(opts, this.connector, this);\n};\n\n/**\n * A #defineEvent shorthand for drivers.\n *\n * Proxies events from an driver's connection to the driver itself.\n *\n * @param {Object} opts proxy options\n * @return {EventEmitter} the driver's connection\n */\nBasestar.prototype.defineDriverEvent = function(opts) {\n  return this._proxyEvents(opts, this.connection, this);\n};\n\nBasestar.prototype._proxyEvents = function(opts, source, target) {\n  opts = _.isString(opts) ? { eventName: opts } : opts;\n\n  opts.source = source;\n  opts.target = target;\n\n  return this.defineEvent(opts);\n};\n","/home/travis/build/npmtest/node-npmtest-cylon/node_modules/cylon/lib/test/test-adaptor.js":"\"use strict\";\n\nvar Adaptor = require(\"../adaptor\"),\n    Utils = require(\"../utils\");\n\nvar TestAdaptor = module.exports = function TestAdaptor() {\n  TestAdaptor.__super__.constructor.apply(this, arguments);\n};\n\nUtils.subclass(TestAdaptor, Adaptor);\n\nTestAdaptor.adaptors = [\"test\"];\nTestAdaptor.adaptor = function(opts) { return new TestAdaptor(opts); };\n","/home/travis/build/npmtest/node-npmtest-cylon/node_modules/cylon/lib/test/test-driver.js":"\"use strict\";\n\nvar Driver = require(\"../driver\"),\n    Utils = require(\"../utils\");\n\nvar TestDriver = module.exports = function TestDriver() {\n  TestDriver.__super__.constructor.apply(this, arguments);\n};\n\nUtils.subclass(TestDriver, Driver);\n\nTestDriver.drivers = [\"test\"];\nTestDriver.driver = function(opts) { return new TestDriver(opts); };\n","/home/travis/build/npmtest/node-npmtest-cylon/node_modules/cylon/lib/driver.js":"\"use strict\";\n\nvar Basestar = require(\"./basestar\"),\n    Utils = require(\"./utils\"),\n    _ = require(\"./utils/helpers\");\n\nfunction formatErrorMessage(name, message) {\n  return [\"Error in driver\", \"'\" + name + \"'\", \"- \" + message].join(\" \");\n}\n\n/**\n * Driver class\n *\n * @constructor Driver\n * @param {Object} [opts] driver options\n * @param {String} [opts.name] the driver's name\n * @param {Object} [opts.robot] the robot the driver belongs to\n * @param {Object} [opts.connection] the adaptor the driver works through\n * @param {Number} [opts.pin] the pin number the driver should have\n * @param {Number} [opts.interval=10] read interval in milliseconds\n */\nvar Driver = module.exports = function Driver(opts) {\n  Driver.__super__.constructor.apply(this, arguments);\n\n  opts = opts || {};\n\n  this.name = opts.name;\n  this.robot = opts.robot;\n\n  this.connection = opts.connection;\n\n  this.commands = {};\n  this.events = [];\n\n  // some default options\n  this.pin = opts.pin;\n  this.interval = opts.interval || 10;\n\n  this.details = {};\n\n  _.each(opts, function(opt, name) {\n    var banned = [\"robot\", \"name\", \"connection\", \"driver\", \"events\"];\n\n    if (!_.includes(banned, name)) {\n      this.details[name] = opt;\n    }\n  }, this);\n};\n\nUtils.subclass(Driver, Basestar);\n\n/**\n * A base start function. Must be overwritten by a descendent.\n *\n * @throws Error if not overridden by a child class\n * @return {void}\n */\nDriver.prototype.start = function() {\n  var message = formatErrorMessage(\n    this.name,\n    \"Driver#start method must be overwritten by descendant classes.\"\n  );\n\n  throw new Error(message);\n};\n\n/**\n * A base halt function. Must be overwritten by a descendent.\n *\n * @throws Error if not overridden by a child class\n * @return {void}\n */\nDriver.prototype.halt = function() {\n  var message = formatErrorMessage(\n    this.name,\n    \"Driver#halt method must be overwritten by descendant classes.\"\n  );\n\n  throw new Error(message);\n};\n\n/**\n * Sets up an array of commands for the Driver.\n *\n * Proxies commands from the Driver to its connection (or a manually specified\n * proxy), and adds a snake_cased version to the driver's commands object.\n *\n * @param {String[]} commands an array of driver commands\n * @param {Object} [proxy=this.connection] proxy target\n * @return {void}\n */\nDriver.prototype.setupCommands = function(commands, proxy) {\n  if (proxy == null) {\n    proxy = this.connection;\n  }\n\n  Utils.proxyFunctionsToObject(commands, proxy, this);\n\n  function endsWith(string, substr) {\n    return string.indexOf(substr, string.length - substr.length) !== -1;\n  }\n\n  commands.forEach(function(command) {\n    var snakeCase = command.replace(/[A-Z]+/g, function(match) {\n      if (match.length > 1 && !endsWith(command, match)) {\n        match = match.replace(/[A-Z]$/, function(m) {\n          return \"_\" + m.toLowerCase();\n        });\n      }\n\n      return \"_\" + match.toLowerCase();\n    }).replace(/^_/, \"\");\n\n    this.commands[snakeCase] = this[command];\n  }, this);\n};\n\n/**\n * Expresses the Driver in a JSON-serializable format\n *\n * @return {Object} a representation of the Driver in a serializable format\n */\nDriver.prototype.toJSON = function() {\n  return {\n    name: this.name,\n    driver: this.constructor.name || this.name,\n    connection: this.connection.name,\n    commands: Object.keys(this.commands),\n    events: this.events,\n    details: this.details\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-cylon/node_modules/cylon/lib/test/ping.js":"\"use strict\";\n\nvar Driver = require(\"../driver\"),\n    Utils = require(\"../utils\");\n\nvar Ping = module.exports = function Ping() {\n  Ping.__super__.constructor.apply(this, arguments);\n\n  this.commands = {\n    ping: this.ping\n  };\n\n  this.events = [\"ping\"];\n};\n\nUtils.subclass(Ping, Driver);\n\nPing.prototype.ping = function() {\n  this.emit(\"ping\", \"ping\");\n  return \"pong\";\n};\n\nPing.prototype.start = function(callback) {\n  callback();\n};\n\nPing.prototype.halt = function(callback) {\n  callback();\n};\n\nPing.drivers = [\"ping\"];\nPing.driver = function(opts) { return new Ping(opts); };\n","/home/travis/build/npmtest/node-npmtest-cylon/node_modules/cylon/lib/validator.js":"\"use strict\";\n\n// validates an Object containing Robot parameters\n\nvar Logger = require(\"./logger\"),\n    _ = require(\"./utils/helpers\");\n\nfunction hasProp(object, prop) {\n  return object.hasOwnProperty(prop);\n}\n\nfunction die() {\n  var RobotDSLError = new Error(\"Unable to start robot due to a syntax error\");\n  RobotDSLError.name = \"RobotDSLError\";\n  throw RobotDSLError;\n}\n\nfunction warn(messages) {\n  messages = [].concat(messages);\n  messages.map(function(msg) { Logger.log(msg); });\n}\n\nfunction fatal(messages) {\n  messages = [].concat(messages);\n  messages.map(function(msg) { Logger.log(msg); });\n  die();\n}\n\nvar checks = {};\n\nchecks.singleObjectSyntax = function(opts, key) {\n  var single = hasProp(opts, key),\n      plural = hasProp(opts, key + \"s\");\n\n  if (single && !plural) {\n    fatal([\n      \"The single-object '\" + key + \"' syntax for robots is not valid.\",\n      \"Instead, use the multiple-value '\" + key + \"s' key syntax.\",\n      \"Details: http://cylonjs.com/documentation/guides/working-with-robots/\"\n    ]);\n  }\n};\n\nchecks.singleObjectSyntax = function(opts) {\n  [\"connection\", \"device\"].map(function(key) {\n    var single = hasProp(opts, key),\n        plural = hasProp(opts, key + \"s\");\n\n    if (single && !plural) {\n      fatal([\n        \"The single-object '\" + key + \"' syntax for robots is not valid.\",\n        \"Instead, use the multiple-value '\" + key + \"s' key syntax.\",\n        \"Details: http://cylonjs.com/documentation/guides/working-with-robots/\"\n      ]);\n    }\n  });\n};\n\nchecks.deviceWithoutDriver = function(opts) {\n  if (opts.devices) {\n    _.each(opts.devices, function(device, name) {\n      if (!device.driver || device.driver === \"\") {\n        fatal(\"No driver supplied for device \" + name);\n      }\n    });\n  }\n};\n\nchecks.devicesWithoutConnection = function(opts) {\n  var connections = opts.connections,\n      devices = opts.devices;\n\n  if (devices && connections && Object.keys(connections).length > 1) {\n    var first = Object.keys(connections)[0];\n\n    _.each(devices, function(device, name) {\n      if (!device.connection || device.connection === \"\") {\n        warn([\n          \"No explicit connection provided for device \" + name,\n          \"Will default to using connection \" + first\n        ]);\n      }\n    });\n  }\n};\n\nchecks.noConnections = function(opts) {\n  var connections = Object.keys(opts.connections || {}).length,\n      devices = Object.keys(opts.devices || {}).length;\n\n  if (devices && !connections) {\n    fatal([\"No connections provided for devices\"]);\n  }\n};\n\nmodule.exports.validate = function validate(opts) {\n  opts = opts || {};\n\n  _.each(checks, function(check) {\n    check(opts);\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-cylon/node_modules/cylon/lib/io/digital-pin.js":"/* eslint no-sync: 0 */\n\n\"use strict\";\n\nvar FS = require(\"fs\"),\n    EventEmitter = require(\"events\").EventEmitter;\n\nvar Utils = require(\"../utils\");\n\nvar GPIO_PATH = \"/sys/class/gpio\";\n\nvar GPIO_READ = \"in\";\nvar GPIO_WRITE = \"out\";\n\n/**\n * The DigitalPin class provides an interface with the Linux GPIO system present\n * in single-board computers such as Raspberry Pi, or Beaglebone Black.\n *\n * @constructor DigitalPin\n * @param {Object} opts digital pin options\n * @param {String} pin which pin number to use\n * @param {String} mode which pin mode to use\n */\nvar DigitalPin = module.exports = function DigitalPin(opts) {\n  this.pinNum = opts.pin.toString();\n  this.status = \"low\";\n  this.ready = false;\n  this.mode = opts.mode;\n};\n\nUtils.subclass(DigitalPin, EventEmitter);\n\nDigitalPin.prototype.connect = function(mode) {\n  if (this.mode == null) {\n    this.mode = mode;\n  }\n\n  FS.exists(this._pinPath(), function(exists) {\n    if (exists) {\n      this._openPin();\n    } else {\n      this._createGPIOPin();\n    }\n  }.bind(this));\n};\n\nDigitalPin.prototype.close = function() {\n  FS.writeFile(this._unexportPath(), this.pinNum, function(err) {\n    this._closeCallback(err);\n  }.bind(this));\n};\n\nDigitalPin.prototype.closeSync = function() {\n  FS.writeFileSync(this._unexportPath(), this.pinNum);\n  this._closeCallback(false);\n};\n\nDigitalPin.prototype.digitalWrite = function(value) {\n  if (this.mode !== \"w\") {\n    this._setMode(\"w\");\n  }\n\n  this.status = value === 1 ? \"high\" : \"low\";\n\n  FS.writeFile(this._valuePath(), value, function(err) {\n    if (err) {\n      var str = \"Error occurred while writing value \";\n      str += value + \" to pin \" + this.pinNum;\n\n      this.emit(\"error\", str);\n    } else {\n      this.emit(\"digitalWrite\", value);\n    }\n  }.bind(this));\n\n  return value;\n};\n\n// Public: Reads the digial pin\"s value periodicly on a supplied interval,\n// and emits the result or an error\n//\n// interval - time (in milliseconds) to read from the pin at\n//\n// Returns the defined interval\nDigitalPin.prototype.digitalRead = function(interval) {\n  if (this.mode !== \"r\") { this._setMode(\"r\"); }\n\n  Utils.every(interval, function() {\n    FS.readFile(this._valuePath(), function(err, data) {\n      if (err) {\n        var error = \"Error occurred while reading from pin \" + this.pinNum;\n        this.emit(\"error\", error);\n      } else {\n        var readData = parseInt(data.toString(), 10);\n        this.emit(\"digitalRead\", readData);\n      }\n    }.bind(this));\n  }.bind(this));\n};\n\nDigitalPin.prototype.setHigh = function() {\n  return this.digitalWrite(1);\n};\n\nDigitalPin.prototype.setLow = function() {\n  return this.digitalWrite(0);\n};\n\nDigitalPin.prototype.toggle = function() {\n  return (this.status === \"low\") ? this.setHigh() : this.setLow();\n};\n\n// Creates the GPIO file to read/write from\nDigitalPin.prototype._createGPIOPin = function() {\n  FS.writeFile(this._exportPath(), this.pinNum, function(err) {\n    if (err) {\n      this.emit(\"error\", \"Error while creating pin files\");\n    } else {\n      this._openPin();\n    }\n  }.bind(this));\n};\n\nDigitalPin.prototype._openPin = function() {\n  this._setMode(this.mode, true);\n  this.emit(\"open\");\n};\n\nDigitalPin.prototype._closeCallback = function(err) {\n  if (err) {\n    this.emit(\"error\", \"Error while closing pin files\");\n  } else {\n    this.emit(\"close\", this.pinNum);\n  }\n};\n\n// Sets the mode for the pin by writing the values to the pin reference files\nDigitalPin.prototype._setMode = function(mode, emitConnect) {\n  if (emitConnect == null) { emitConnect = false; }\n\n  this.mode = mode;\n\n  var data = (mode === \"w\") ? GPIO_WRITE : GPIO_READ;\n\n  FS.writeFile(this._directionPath(), data, function(err) {\n    this._setModeCallback(err, emitConnect);\n  }.bind(this));\n};\n\nDigitalPin.prototype._setModeCallback = function(err, emitConnect) {\n  if (err) {\n    return this.emit(\"error\", \"Setting up pin direction failed\");\n  }\n\n  this.ready = true;\n\n  if (emitConnect) {\n    this.emit(\"connect\", this.mode);\n  }\n};\n\nDigitalPin.prototype._directionPath = function() {\n  return this._pinPath() + \"/direction\";\n};\n\nDigitalPin.prototype._valuePath = function() {\n  return this._pinPath() + \"/value\";\n};\n\nDigitalPin.prototype._pinPath = function() {\n  return GPIO_PATH + \"/gpio\" + this.pinNum;\n};\n\nDigitalPin.prototype._exportPath = function() {\n  return GPIO_PATH + \"/export\";\n};\n\nDigitalPin.prototype._unexportPath = function() {\n  return GPIO_PATH + \"/unexport\";\n};\n","/home/travis/build/npmtest/node-npmtest-cylon/node_modules/cylon/lib/io/utils.js":"\"use strict\";\n\nmodule.exports = {\n  /**\n   * Calculates PWM Period and Duty based on provided params.\n   *\n   * @param {Number} scaledDuty the scaled duty value\n   * @param {Number} freq frequency to use\n   * @param {Number} pulseWidth pulse width\n   * @param {String} [polarity=high] polarity value (high or low)\n   * @return {Object} calculated period and duty encapsulated in an object\n   */\n  periodAndDuty: function(scaledDuty, freq, pulseWidth, polarity) {\n    var period, duty, maxDuty;\n\n    polarity = polarity || \"high\";\n    period = Math.round(1.0e9 / freq);\n\n    if (pulseWidth != null) {\n      var pulseWidthMin = pulseWidth.min * 1000,\n          pulseWidthMax = pulseWidth.max * 1000;\n\n      maxDuty = pulseWidthMax - pulseWidthMin;\n      duty = Math.round(pulseWidthMin + (maxDuty * scaledDuty));\n    } else {\n      duty = Math.round(period * scaledDuty);\n    }\n\n    if (polarity === \"low\") {\n      duty = period - duty;\n    }\n\n    return { period: period, duty: duty };\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-cylon/node_modules/cylon/lib/api.js":"\"use strict\";\n\nvar MCP = require(\"./mcp\"),\n    Logger = require(\"./logger\"),\n    _ = require(\"./utils/helpers\");\n\nvar api = module.exports = {};\n\napi.instances = [];\n\n/**\n * Creates a new API instance\n *\n * @param {String} [Server] which API plugin to use (e.g. \"http\" loads\n * cylon-api-http)\n * @param {Object} opts options for the new API instance\n * @return {void}\n */\napi.create = function create(Server, opts) {\n  // if only passed options (or nothing), assume HTTP server\n  if (Server == null || _.isObject(Server) && !_.isFunction(Server)) {\n    opts = Server;\n    Server = \"http\";\n  }\n\n  opts = opts || {};\n\n  if (_.isString(Server)) {\n    var req = \"cylon-api-\" + Server;\n\n    try {\n      Server = require(req);\n    } catch (e) {\n      if (e.code !== \"MODULE_NOT_FOUND\") {\n        throw e;\n      }\n\n      [\n        \"Cannot find the \" + req + \" API module.\",\n        \"You may be able to install it: `npm install \" + req + \"`\"\n      ].forEach(Logger.log);\n\n      throw new Error(\"Missing API plugin - cannot proceed\");\n    }\n  }\n\n  opts.mcp = MCP;\n\n  var instance = new Server(opts);\n  api.instances.push(instance);\n  instance.start();\n};\n"}